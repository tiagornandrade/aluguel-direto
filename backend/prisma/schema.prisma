generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String        @id @default(cuid())
  email            String        @unique
  fullName         String
  cpf              String?
  rg               String?
  nacionalidade    String?
  estadoCivil      String?
  profissao        String?
  endereco         String?
  passwordHash     String
  role             String        // PROPRIETARIO | INQUILINO
  profileCompleted Boolean       @default(false)
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  sessions         Session[]
  properties       Property[]
  contractsAsTenant Contract[]   @relation("TenantContracts")
  contractsAsOwner  Contract[]   @relation("OwnerContracts")
  notificationsReceived Notification[] @relation("NotificationsReceived")
  notificationsSent   Notification[] @relation("NotificationsSent")
  conversationsAsOwner    Conversation[] @relation("ConversationOwner")
  conversationsAsOther    Conversation[] @relation("ConversationOther")
  messagesSent            Message[]

  @@map("users")
}

model Property {
  id             String    @id @default(cuid())
  ownerId        String
  title          String
  addressLine    String
  type           String    // APARTAMENTO | CASA | STUDIO | COBERTURA
  areaM2         Float?
  rooms          Int?
  parkingSpots   Int?
  rentAmount     Float?
  chargesAmount  Float?
  status         String    @default("DISPONIVEL") // DISPONIVEL | EM_NEGOCIACAO | ALUGADO | ENCERRADO
  photos         String[]  @default([])           // IDs de PropertyPhoto (upload) ou URLs externas
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  owner         User           @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  contracts     Contract[]
  notifications Notification[]
  conversations Conversation[]
  photoBlobs    PropertyPhoto[]

  @@map("properties")
}

model PropertyPhoto {
  id          String   @id @default(cuid())
  propertyId  String
  contentType String   // image/jpeg, image/png, etc.
  data        Bytes    // conteúdo binário da imagem
  createdAt   DateTime @default(now())

  property Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  @@map("property_photos")
}

model Contract {
  id               String    @id @default(cuid())
  propertyId       String
  tenantId         String
  ownerId          String
  startDate        DateTime
  endDate          DateTime
  rentAmount       Float
  chargesAmount    Float     @default(0)
  dueDay           Int       // 1-28
  status           String    @default("PENDENTE_ASSINATURA") // PENDENTE_ASSINATURA | ATIVO | ENCERRADO
  paymentMethod    String?   // PIX, Transferência, Boleto, etc.
  lateFeePercent   Float?   // multa %
  interestPercent  Float?   // juros % ao mês
  adjustmentIndex  String?  // IGPM, IPCA, etc.
  guaranteeType    String?   // CAUCAO | FIADOR | SEGURO_FIANCA
  guaranteeAmount  Float?   // valor caução R$
  foroComarca      String?
  contractCity     String?
  contractDate     DateTime?
  tenantSignedAt      DateTime?  // data/hora em que o locatário assinou
  tenantSignedIp      String?   // IP no momento da assinatura (comprovação)
  tenantSignedUserAgent String? // User-Agent no momento da assinatura (comprovação)
  ownerSignedAt       DateTime?
  ownerSignedIp       String?
  ownerSignedUserAgent String?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  property Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  tenant   User     @relation("TenantContracts", fields: [tenantId], references: [id], onDelete: Cascade)
  owner    User     @relation("OwnerContracts", fields: [ownerId], references: [id], onDelete: Cascade)
  installments RentInstallment[]
  tenantDocuments TenantDocument[]
  notifications   Notification[]

  @@map("contracts")
}

model TenantDocument {
  id             String    @id @default(cuid())
  contractId     String
  tenantId       String
  type           String    // RG | CPF | COMPROVANTE_RENDA | COMPROVANTE_ENDERECO
  fileName       String
  contentType    String    // application/pdf, image/jpeg, etc.
  data           Bytes
  status         String    @default("PENDENTE_ANALISE") // PENDENTE_ANALISE | APROVADO | REJEITADO
  rejectedReason String?   @db.Text
  reviewedAt     DateTime?
  reviewedById   String?
  analysisResult Json?     // resultado da análise por IA (resumo, checklist)
  analyzedAt     DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  contract Contract @relation(fields: [contractId], references: [id], onDelete: Cascade)

  @@map("tenant_documents")
}

model RentInstallment {
  id             String    @id @default(cuid())
  contractId     String
  referenceMonth Int       // 1-12
  referenceYear  Int
  amount         Float     // rentAmount + chargesAmount (pode variar com reajuste)
  dueDate        DateTime  // dia do vencimento no mês/ano
  status         String    @default("PENDENTE") // PENDENTE | PAGO | ATRASADO
  paidAt         DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  contract Contract @relation(fields: [contractId], references: [id], onDelete: Cascade)

  @@unique([contractId, referenceMonth, referenceYear])
  @@map("rent_installments")
}

model Notification {
  id             String    @id @default(cuid())
  recipientId    String
  senderId       String
  type           String    // CONTACT_REQUEST | PEDIDO_* | SOLICITACAO_LOCADOR_TROCA | NOVA_MENSAGEM
  propertyId     String?
  contractId     String?
  conversationId String?
  message        String?
  read           Boolean   @default(false)
  createdAt      DateTime  @default(now())

  recipient User     @relation("NotificationsReceived", fields: [recipientId], references: [id], onDelete: Cascade)
  sender    User     @relation("NotificationsSent", fields: [senderId], references: [id], onDelete: Cascade)
  property  Property? @relation(fields: [propertyId], references: [id], onDelete: SetNull)
  contract  Contract? @relation(fields: [contractId], references: [id], onDelete: SetNull)

  @@map("notifications")
}

model Conversation {
  id                 String   @id @default(cuid())
  propertyId         String
  ownerId            String   // proprietário do imóvel
  otherParticipantId String   // inquilino ou interessado
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  property       Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  owner          User      @relation("ConversationOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  otherParticipant User     @relation("ConversationOther", fields: [otherParticipantId], references: [id], onDelete: Cascade)
  messages       Message[]

  @@unique([propertyId, otherParticipantId])
  @@map("conversations")
}

model Message {
  id             String   @id @default(cuid())
  conversationId String
  senderId       String
  content        String   @db.Text
  createdAt      DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@map("messages")
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  expiresAt DateTime
  ip        String?
  userAgent String?
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}
